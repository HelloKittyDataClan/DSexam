from pandas import read_csv, Series
from rdflib import RDF
from rdflib import Graph, URIRef, RDF, Literal, Namespace

class Handler: 
    def __init__(self): 
        self.dbPathOrUrl = "" 

    def getDbPathOrUrl(self): 
        return self.dbPathOrUrl  

    def setDbPathOrUrl(self, newpath): 
        if len(newpath.split('.')) and newpath.split('.')[-1] == "db": 
            self.dbPathOrUrl = newpath 
            return True 
        elif len(up.urlparse(newpath).scheme) and len(up.urlparse(newpath).netloc): 
            self.dbPathOrUrl = newpath 
            return True 
        return False 
 

class UploadHandler(Handler): 
    def __init__(self): 
        super().__init__() 

    def pushDataToDb(self): 
        pass 

class MetadataUploadHandler(UploadHandler):
    def pushDataToDb(self, path):

    #define namespaces
    schema = Namespace("http://schema.org/")
    foaf = Namespace ("http://xmlns.com/foaf/0.1/")  #related to person
    my_git = Namespace ("http://github.com/HelloKittyDataClan/DSexam")
   
    #create Graph
    meta_graph = Graph()
    meta_graph.bind = ("schema", schema)
    meta_graph.bind = ("foaf", schema)
    meta_graph.bind = ("git", my_git)

  # attributes related to classes
    title = URIRef("https://schema.org/title")
    date = URIRef("https://schema.org/dateCreated")
    owner = URIRef("http://github.com/HelloKittyDataClan/DSexam/owner")
    place = URIRef("https://schema.org/itemLocation")

    identifier=URIRef("https://schema.org/identifier")

    #relation with authors among classes
    author=URIRef("https://schema.org/author")

    #attributes related to the class Person
    name=URIRef("<http://xmlns.com/foaf/0.1/name>")

    #definie classes about Cultural Object
    Person = URIRef(foaf.Person)
    NauticalChart = URIRef(my_git.NauticalChart)
    ManuscriptPlate = URIRef(my_git.ManuscriptPlate)
    ManuscriptVolume = URIRef(my_git.ManuscriptVolume)
    PrintedVolume = URIRef(my_git.PrintedVolume)
    PrintedMaterial = URIRef(my_git.PrintedMaterial)
    Herbarium = URIRef(my_git.Herbarium)
    Specimen = URIRef(my_git.Specimen)
    Painting = URIRef(my_git.Painting) 
    Model = URIRef(my_git.Model)
    Map = URIRef(schema.Map)

# This is the string defining the base URL used to defined
# the URLs of all the resources created from the data
    base_url = Namespace ("http://github.com/HelloKittyDataClan/DSexam")

    venus=read_csv(".../data/meta.csv",
                    path,
                    keep_default_na=False,
                        dtype={
                        "Id": "string",
                        "Title": "string",
                        "Date" : "string",
                        "Owner": "string",
                        "Place": "string",
                        "Type":"string"
                        "Author": "string"
                        }
                )

    for idx, row in venus.iterrows():   #mi restituisce un indice e un row che contiene i valori delle colonne
        internal_id = "culturalobject-" + str(idx)  
        subject = URIRef(base_url + internal_id)

        if row["Id"] != "":
            meta_graph.add(subject, identifier, Literal (row["Id"]))

        if row["Title"] != "":
            meta_graph.add(subject, title, Literal(row["Title"]))

        if row["Date"] != "":
            meta_graph.add(subject, date, Literal (row["Date"]))
        
        if row["Owner"] != "":
            meta_graph.add(subject, owner, Literal (row["Owner"]))
        
        if row["Place"] != "":
            meta_graph.add(subject, place, Literal (row["Place"]))

        # add to a Graph the Cultural Object
        if row["Type"] != "":
            if row["Type"].lower()=="nautical chart":
                meta_graph.add((subject, RDF.type, NauticalChart))

            elif row["Type"].lower()=="manuscript plate":
                meta_graph.add((subject, RDF.type, ManuscriptPlate))
    
            elif row["Type"].lower()=="manuscript volume":
                meta_graph.add((subject, RDF.type, ManuscriptVolume))
    
            elif row["Type"].lower()=="printed volume":
                meta_graph.add((subject, RDF.type, PrintedVolume))

            elif row["Type"].lower()=="printed material":
                meta_graph.add((subject, RDF.type, PrintedMaterial))

            elif row["Type"].lower()=="herbarium":
                meta_graph.add((subject, RDF.type, Herbarium))

            elif row["Type"].lower()=="specimen":
                meta_graph.add((subject, RDF.type, Specimen))

            elif row["Type"].lower()=="painting":
                meta_graph.add((subject, RDF.type, Painting))

            elif row["Type"].lower()=="model":
                meta_graph.add((subject, RDF.type, Model))
        
            elif row["Type"].lower()=="map":
                meta_graph.add((subject, RDF.type, Map))

            #add author




    # AGGIUNTA IMPLEMENTAZIONE AUTORI (DA VEDERE DOVE POSIZIONARLA)
    index_dict = df_with_all_people_from_db.set_index('id')['entity'].to_dict()  #creazione dizionario che mappa gli ID delle persone dal DF alle entità corrispondenti
        filter_list = sorted(list(index_dict.keys()))
        authors_expanded = venus['Author'].str.split('; ', expand=True)    #verifica se gli autori nel DF 'venus' (lo otteniamo noi questo oggetto Pandas con read_CSV) sono già presenti nel DB RDF più la loro espansione
        rows = []
        for col in authors_expanded.columns:                                      #iterazione su ogni colonna       
            author_id_split = authors_expanded[col].str.split('(', expand=True)            
            author_id_split.columns = ['Author', 'Author_ID']
            author_id_split['Author_ID'] = author_id_split['Author_ID'].str[:-1]      #qui avviene la divisione e formattazione: ogni valore viene diviso con ( per estrarre l'id dell'autore e il suo nome
            rows.extend(author_id_split.values.tolist())                              #informazioni ottenute vengono inserite in una lista di Tuple che è 'rows'
        
        new_df = pd.DataFrame(rows, columns=['Author', 'Author_ID'])                  #lista rows serve per creare un nuovo DF con Author e Author_ID
        new_df.dropna(inplace=True)
        filtered_df = new_df[~new_df['Author_ID'].isin(filter_list)]                  #filtraggio degli autori ossia nuovo DF che contiene solo gli autori non presenti nel DF RDF ossia dove l'ID non è incluso in filter_list
        
        object_id_author = {}
        ids_of_unique_authors = {}
        author_id = df_res['personCount'][0]

        for _, row in venus.iterrows():                                              #iterazione su 'venus'
            if row['Author']:
                pattern_id = r'\((.*?)\)' 
                pattern_name = r'^([^()]+)'
                authors = [s.strip() for s in row['Author'].split(";")]              #in ogni riga, gli autori vengono separaati utilizzando ;, così da essere analizzati separatamente

                for author_str in authors:                                           #utilizza espressione regolare per estrarre l'id e il nome di ogni autore
                    match_id = re.search(pattern_id, author_str)
                    match_name = re.search(pattern_name, author_str)

                    if match_id and match_name:
                        person_id = match_id.group(1)
                        person_name = match_name.group(1).strip()
                        object_id = row['Id']

                        if person_id not in ids_of_unique_authors and person_id in filtered_df['Author_ID'].tolist():
                            subject = URIRef(ns_dict["Entities"] + f'person-{author_id}')
                            author_id += 1

                            meta_graph.add((subject, RDF.type, Person))
                            meta_graph.add((subject, predicates['id'], Literal(person_id)))
                            meta_graph.add((subject, predicates['name'], Literal(person_name)))
                            ids_of_unique_authors[person_id] = subject

                        if person_id in list(ids_of_unique_authors.keys()):
                            subject = ids_of_unique_authors[person_id]
                        else:
                            subject = URIRef(index_dict[person_id])
                        object_id_author.setdefault(object_id, []).append(subject)



        #AGGIUNTA AUTORI AL GRAFO
        for object_id, authors_list in object_id_author.items():
            for author in authors_list:
                meta_graph.add((URIRef(base_url + f"culturalobject-{object_id}"), author, author))            

    #Se un autore è presente nel database RDF, viene aggiunto al grafo RDF. Se non è presente, viene creato un nuovo nodo per l'autore e aggiunto al grafo. Viene inoltre creato un dizionario object_id_author che mappa gli ID degli oggetti culturali agli autori associati.
